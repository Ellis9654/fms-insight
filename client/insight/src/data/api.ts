/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.14.0.0 (NJsonSchema v9.10.24.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class InspectionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = <any>undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    forceInspection(materialID: number, inspectionType: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/inspection/material/{materialID}/{inspectionType}";
        if (materialID === undefined || materialID === null)
            throw new Error("The parameter 'materialID' must be defined.");
        url_ = url_.replace("{materialID}", encodeURIComponent("" + materialID));
        if (inspectionType === undefined || inspectionType === null)
            throw new Error("The parameter 'inspectionType' must be defined.");
        url_ = url_.replace("{inspectionType}", encodeURIComponent("" + inspectionType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: new Headers({
                "Content-Type": "application/json",
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForceInspection(_response);
        });
    }

    protected processForceInspection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    nextPieceInspection(pallet: number, location: PalletLocationEnum, inspectionType: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/inspection/pallet/{pallet}/{location}/{inspectionType}";
        if (pallet === undefined || pallet === null)
            throw new Error("The parameter 'pallet' must be defined.");
        url_ = url_.replace("{pallet}", encodeURIComponent("" + pallet));
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined.");
        url_ = url_.replace("{location}", encodeURIComponent("" + location));
        if (inspectionType === undefined || inspectionType === null)
            throw new Error("The parameter 'inspectionType' must be defined.");
        url_ = url_.replace("{inspectionType}", encodeURIComponent("" + inspectionType));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: new Headers({
                "Content-Type": "application/json",
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processNextPieceInspection(_response);
        });
    }

    protected processNextPieceInspection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    getCounts(): Promise<InspectCount[]> {
        let url_ = this.baseUrl + "/api/v1/inspection/counts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCounts(_response);
        });
    }

    protected processGetCounts(response: Response): Promise<InspectCount[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(InspectCount.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InspectCount[]>(<any>null);
    }

    setCounts(newCounts: InspectCount[]): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/inspection/counts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newCounts);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: new Headers({
                "Content-Type": "application/json",
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetCounts(_response);
        });
    }

    protected processSetCounts(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    getGlobalInspectionTypes(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/inspection/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGlobalInspectionTypes(_response);
        });
    }

    protected processGetGlobalInspectionTypes(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    getGlobalInspectionType(ty: string): Promise<InspectionType> {
        let url_ = this.baseUrl + "/api/v1/inspection/type/{ty}";
        if (ty === undefined || ty === null)
            throw new Error("The parameter 'ty' must be defined.");
        url_ = url_.replace("{ty}", encodeURIComponent("" + ty));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGlobalInspectionType(_response);
        });
    }

    protected processGetGlobalInspectionType(response: Response): Promise<InspectionType> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InspectionType.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InspectionType>(<any>null);
    }

    setGlobalInspection(ty: string, ity: InspectionType): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/inspection/type/{ty}";
        if (ty === undefined || ty === null)
            throw new Error("The parameter 'ty' must be defined.");
        url_ = url_.replace("{ty}", encodeURIComponent("" + ty));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ity);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: new Headers({
                "Content-Type": "application/json",
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetGlobalInspection(_response);
        });
    }

    protected processSetGlobalInspection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    deleteGlobalInspection(ty: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/inspection/type/{ty}";
        if (ty === undefined || ty === null)
            throw new Error("The parameter 'ty' must be defined.");
        url_ = url_.replace("{ty}", encodeURIComponent("" + ty));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: new Headers({
                "Content-Type": "application/json",
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteGlobalInspection(_response);
        });
    }

    protected processDeleteGlobalInspection(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class JobsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = <any>undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    history(startUTC: Date, endUTC: Date): Promise<HistoricData> {
        let url_ = this.baseUrl + "/api/v1/jobs/history?";
        if (startUTC === undefined || startUTC === null)
            throw new Error("The parameter 'startUTC' must be defined and cannot be null.");
        else
            url_ += "startUTC=" + encodeURIComponent(startUTC ? "" + startUTC.toJSON() : "") + "&";
        if (endUTC === undefined || endUTC === null)
            throw new Error("The parameter 'endUTC' must be defined and cannot be null.");
        else
            url_ += "endUTC=" + encodeURIComponent(endUTC ? "" + endUTC.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processHistory(_response);
        });
    }

    protected processHistory(response: Response): Promise<HistoricData> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HistoricData.fromJS(resultData200) : new HistoricData();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HistoricData>(<any>null);
    }

    recent(afterScheduleId: string): Promise<JobsAndExtraParts> {
        let url_ = this.baseUrl + "/api/v1/jobs/recent?";
        if (afterScheduleId === undefined)
            throw new Error("The parameter 'afterScheduleId' must be defined.");
        else
            url_ += "afterScheduleId=" + encodeURIComponent("" + afterScheduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecent(_response);
        });
    }

    protected processRecent(response: Response): Promise<JobsAndExtraParts> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobsAndExtraParts.fromJS(resultData200) : new JobsAndExtraParts();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobsAndExtraParts>(<any>null);
    }

    latestSchedule(): Promise<JobsAndExtraParts> {
        let url_ = this.baseUrl + "/api/v1/jobs/latest-schedule";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLatestSchedule(_response);
        });
    }

    protected processLatestSchedule(response: Response): Promise<JobsAndExtraParts> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? JobsAndExtraParts.fromJS(resultData200) : new JobsAndExtraParts();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobsAndExtraParts>(<any>null);
    }

    mostRecentUnfilledWorkordersForPart(part: string): Promise<PartWorkorder[]> {
        let url_ = this.baseUrl + "/api/v1/jobs/unfilled-workorders/by-part/{part}";
        if (part === undefined || part === null)
            throw new Error("The parameter 'part' must be defined.");
        url_ = url_.replace("{part}", encodeURIComponent("" + part));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processMostRecentUnfilledWorkordersForPart(_response);
        });
    }

    protected processMostRecentUnfilledWorkordersForPart(response: Response): Promise<PartWorkorder[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PartWorkorder.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PartWorkorder[]>(<any>null);
    }

    currentStatus(): Promise<CurrentStatus> {
        let url_ = this.baseUrl + "/api/v1/jobs/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCurrentStatus(_response);
        });
    }

    protected processCurrentStatus(response: Response): Promise<CurrentStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentStatus.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CurrentStatus>(<any>null);
    }

    checkValid(jobs: JobPlan[]): Promise<string[]> {
        let url_ = this.baseUrl + "/api/v1/jobs/check-valid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(jobs);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckValid(_response);
        });
    }

    protected processCheckValid(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }

    add(newJobs: NewJobs, expectedPreviousScheduleId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/jobs/add?";
        if (expectedPreviousScheduleId === undefined)
            throw new Error("The parameter 'expectedPreviousScheduleId' must be defined.");
        else
            url_ += "expectedPreviousScheduleId=" + encodeURIComponent("" + expectedPreviousScheduleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newJobs);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: new Headers({
                "Content-Type": "application/json",
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    decrementQuantities(loadDecrementsStrictlyAfterDecrementId: string, loadDecrementsAfterTimeUTC: Date): Promise<JobAndDecrementQuantity[]> {
        let url_ = this.baseUrl + "/api/v1/jobs/planned-cycles?";
        if (loadDecrementsStrictlyAfterDecrementId !== undefined)
            url_ += "loadDecrementsStrictlyAfterDecrementId=" + encodeURIComponent("" + loadDecrementsStrictlyAfterDecrementId) + "&";
        if (loadDecrementsAfterTimeUTC !== undefined)
            url_ += "loadDecrementsAfterTimeUTC=" + encodeURIComponent(loadDecrementsAfterTimeUTC ? "" + loadDecrementsAfterTimeUTC.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDecrementQuantities(_response);
        });
    }

    protected processDecrementQuantities(response: Response): Promise<JobAndDecrementQuantity[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(JobAndDecrementQuantity.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobAndDecrementQuantity[]>(<any>null);
    }
}

export class LogClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = <any>undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(startUTC: Date, endUTC: Date): Promise<LogEntry[]> {
        let url_ = this.baseUrl + "/api/v1/log/events/all?";
        if (startUTC === undefined || startUTC === null)
            throw new Error("The parameter 'startUTC' must be defined and cannot be null.");
        else
            url_ += "startUTC=" + encodeURIComponent(startUTC ? "" + startUTC.toJSON() : "") + "&";
        if (endUTC === undefined || endUTC === null)
            throw new Error("The parameter 'endUTC' must be defined and cannot be null.");
        else
            url_ += "endUTC=" + encodeURIComponent(endUTC ? "" + endUTC.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LogEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry[]>(<any>null);
    }

    getCompletedParts(startUTC: Date, endUTC: Date): Promise<LogEntry[]> {
        let url_ = this.baseUrl + "/api/v1/log/events/all-completed-parts?";
        if (startUTC === undefined || startUTC === null)
            throw new Error("The parameter 'startUTC' must be defined and cannot be null.");
        else
            url_ += "startUTC=" + encodeURIComponent(startUTC ? "" + startUTC.toJSON() : "") + "&";
        if (endUTC === undefined || endUTC === null)
            throw new Error("The parameter 'endUTC' must be defined and cannot be null.");
        else
            url_ += "endUTC=" + encodeURIComponent(endUTC ? "" + endUTC.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompletedParts(_response);
        });
    }

    protected processGetCompletedParts(response: Response): Promise<LogEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry[]>(<any>null);
    }

    recent(lastSeenCounter: number): Promise<LogEntry[]> {
        let url_ = this.baseUrl + "/api/v1/log/events/recent?";
        if (lastSeenCounter === undefined || lastSeenCounter === null)
            throw new Error("The parameter 'lastSeenCounter' must be defined and cannot be null.");
        else
            url_ += "lastSeenCounter=" + encodeURIComponent("" + lastSeenCounter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRecent(_response);
        });
    }

    protected processRecent(response: Response): Promise<LogEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry[]>(<any>null);
    }

    logForMaterial(materialID: number): Promise<LogEntry[]> {
        let url_ = this.baseUrl + "/api/v1/log/events/for-material/{materialID}";
        if (materialID === undefined || materialID === null)
            throw new Error("The parameter 'materialID' must be defined.");
        url_ = url_.replace("{materialID}", encodeURIComponent("" + materialID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogForMaterial(_response);
        });
    }

    protected processLogForMaterial(response: Response): Promise<LogEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry[]>(<any>null);
    }

    logForSerial(serial: string): Promise<LogEntry[]> {
        let url_ = this.baseUrl + "/api/v1/log/events/for-serial/{serial}";
        if (serial === undefined || serial === null)
            throw new Error("The parameter 'serial' must be defined.");
        url_ = url_.replace("{serial}", encodeURIComponent("" + serial));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogForSerial(_response);
        });
    }

    protected processLogForSerial(response: Response): Promise<LogEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry[]>(<any>null);
    }

    logForWorkorder(workorder: string): Promise<LogEntry[]> {
        let url_ = this.baseUrl + "/api/v1/log/events/for-workorder/{workorder}";
        if (workorder === undefined || workorder === null)
            throw new Error("The parameter 'workorder' must be defined.");
        url_ = url_.replace("{workorder}", encodeURIComponent("" + workorder));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogForWorkorder(_response);
        });
    }

    protected processLogForWorkorder(response: Response): Promise<LogEntry[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(LogEntry.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry[]>(<any>null);
    }

    getWorkorders(workorderIds: string[]): Promise<WorkorderSummary[]> {
        let url_ = this.baseUrl + "/api/v1/log/workorders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(workorderIds);

        let options_ = <RequestInit>{
            body: content_,
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWorkorders(_response);
        });
    }

    protected processGetWorkorders(response: Response): Promise<WorkorderSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(WorkorderSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WorkorderSummary[]>(<any>null);
    }

    setSerial(serial: string, mat: LogMaterial): Promise<LogEntry> {
        let url_ = this.baseUrl + "/api/v1/log/serial/{serial}/material";
        if (serial === undefined || serial === null)
            throw new Error("The parameter 'serial' must be defined.");
        url_ = url_.replace("{serial}", encodeURIComponent("" + serial));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mat);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetSerial(_response);
        });
    }

    protected processSetSerial(response: Response): Promise<LogEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogEntry.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry>(<any>null);
    }

    setWorkorder(workorder: string, mat: LogMaterial): Promise<LogEntry> {
        let url_ = this.baseUrl + "/api/v1/log/workorder/{workorder}/material";
        if (workorder === undefined || workorder === null)
            throw new Error("The parameter 'workorder' must be defined.");
        url_ = url_.replace("{workorder}", encodeURIComponent("" + workorder));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(mat);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetWorkorder(_response);
        });
    }

    protected processSetWorkorder(response: Response): Promise<LogEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogEntry.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry>(<any>null);
    }

    finalizeWorkorder(workorder: string): Promise<LogEntry> {
        let url_ = this.baseUrl + "/api/v1/log/workorder/{workorder}/finalize";
        if (workorder === undefined || workorder === null)
            throw new Error("The parameter 'workorder' must be defined.");
        url_ = url_.replace("{workorder}", encodeURIComponent("" + workorder));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFinalizeWorkorder(_response);
        });
    }

    protected processFinalizeWorkorder(response: Response): Promise<LogEntry> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LogEntry.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LogEntry>(<any>null);
    }

    getSerialSettings(): Promise<SerialSettings> {
        let url_ = this.baseUrl + "/api/v1/log/settings/serials";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSerialSettings(_response);
        });
    }

    protected processGetSerialSettings(response: Response): Promise<SerialSettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SerialSettings.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SerialSettings>(<any>null);
    }

    setSerialSettings(settings: SerialSettings): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/log/settings/serials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: new Headers({
                "Content-Type": "application/json",
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetSerialSettings(_response);
        });
    }

    protected processSetSerialSettings(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class ServerClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: (key: string, value: any) => any = <any>undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    pluginInfo(): Promise<PluginInfo> {
        let url_ = this.baseUrl + "/api/v1/server/plugin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPluginInfo(_response);
        });
    }

    protected processPluginInfo(response: Response): Promise<PluginInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PluginInfo.fromJS(resultData200) : new PluginInfo();
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PluginInfo>(<any>null);
    }

    getSettings(id: string): Promise<string> {
        let url_ = this.baseUrl + "/api/v1/server/settings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: new Headers({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSettings(_response);
        });
    }

    protected processGetSettings(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    setSetting(id: string, setting: string): Promise<void> {
        let url_ = this.baseUrl + "/api/v1/server/settings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(setting);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: new Headers({
                "Content-Type": "application/json",
            })
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetSetting(_response);
        });
    }

    protected processSetSetting(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export enum PalletLocationEnum {
    LoadUnload = <any>"LoadUnload",
    Machine = <any>"Machine",
    MachineQueue = <any>"MachineQueue",
    Buffer = <any>"Buffer",
    Cart = <any>"Cart",
}

export abstract class ValueType implements IValueType {

    constructor(data?: IValueType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
        }
    }

    static fromJS(data: any): ValueType {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ValueType' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IValueType {
}

export class InspectCount extends ValueType implements IInspectCount {
    counter: string;
    value: number;
    lastUTC: Date;

    constructor(data?: IInspectCount) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.counter = data["counter"];
            this.value = data["value"];
            this.lastUTC = data["lastUTC"] ? new Date(data["lastUTC"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): InspectCount {
        data = typeof data === 'object' ? data : {};
        let result = new InspectCount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counter"] = this.counter;
        data["value"] = this.value;
        data["lastUTC"] = this.lastUTC ? this.lastUTC.toISOString() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IInspectCount extends IValueType {
    counter: string;
    value: number;
    lastUTC: Date;
}

export class InspectionType implements IInspectionType {
    overrides: InspectionFrequencyOverride[] = [];
    name: string;
    trackPartName: boolean;
    trackPalletName: boolean;
    trackStationName: boolean;
    inspectSingleProcess: number;
    defaultCountToTriggerInspection: number;
    defaultDeadline: string;
    defaultRandomFreq: number;

    constructor(data?: IInspectionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["overrides"] && data["overrides"].constructor === Array) {
                this.overrides = [];
                for (let item of data["overrides"])
                    this.overrides.push(InspectionFrequencyOverride.fromJS(item));
            }
            this.name = data["name"];
            this.trackPartName = data["trackPartName"];
            this.trackPalletName = data["trackPalletName"];
            this.trackStationName = data["trackStationName"];
            this.inspectSingleProcess = data["inspectSingleProcess"];
            this.defaultCountToTriggerInspection = data["defaultCountToTriggerInspection"];
            this.defaultDeadline = data["defaultDeadline"];
            this.defaultRandomFreq = data["defaultRandomFreq"];
        }
    }

    static fromJS(data: any): InspectionType {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.overrides && this.overrides.constructor === Array) {
            data["overrides"] = [];
            for (let item of this.overrides)
                data["overrides"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["trackPartName"] = this.trackPartName;
        data["trackPalletName"] = this.trackPalletName;
        data["trackStationName"] = this.trackStationName;
        data["inspectSingleProcess"] = this.inspectSingleProcess;
        data["defaultCountToTriggerInspection"] = this.defaultCountToTriggerInspection;
        data["defaultDeadline"] = this.defaultDeadline;
        data["defaultRandomFreq"] = this.defaultRandomFreq;
        return data;
    }
}

export interface IInspectionType {
    overrides: InspectionFrequencyOverride[];
    name: string;
    trackPartName: boolean;
    trackPalletName: boolean;
    trackStationName: boolean;
    inspectSingleProcess: number;
    defaultCountToTriggerInspection: number;
    defaultDeadline: string;
    defaultRandomFreq: number;
}

export class InspectionFrequencyOverride implements IInspectionFrequencyOverride {
    part: string;
    countBeforeInspection: number;
    deadline: string;
    randomFreq: number;

    constructor(data?: IInspectionFrequencyOverride) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.part = data["part"];
            this.countBeforeInspection = data["countBeforeInspection"];
            this.deadline = data["deadline"];
            this.randomFreq = data["randomFreq"];
        }
    }

    static fromJS(data: any): InspectionFrequencyOverride {
        data = typeof data === 'object' ? data : {};
        let result = new InspectionFrequencyOverride();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["part"] = this.part;
        data["countBeforeInspection"] = this.countBeforeInspection;
        data["deadline"] = this.deadline;
        data["randomFreq"] = this.randomFreq;
        return data;
    }
}

export interface IInspectionFrequencyOverride {
    part: string;
    countBeforeInspection: number;
    deadline: string;
    randomFreq: number;
}

export class HistoricData extends ValueType implements IHistoricData {
    jobs: { [key: string] : JobPlan; } = {};
    stationUse: SimulatedStationUtilization[] = [];

    constructor(data?: IHistoricData) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["jobs"]) {
                this.jobs = {};
                for (let key in data["jobs"]) {
                    if (data["jobs"].hasOwnProperty(key))
                        this.jobs[key] = data["jobs"][key] ? JobPlan.fromJS(data["jobs"][key]) : new JobPlan();
                }
            }
            if (data["stationUse"] && data["stationUse"].constructor === Array) {
                this.stationUse = [];
                for (let item of data["stationUse"])
                    this.stationUse.push(SimulatedStationUtilization.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HistoricData {
        data = typeof data === 'object' ? data : {};
        let result = new HistoricData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.jobs) {
            data["jobs"] = {};
            for (let key in this.jobs) {
                if (this.jobs.hasOwnProperty(key))
                    data["jobs"][key] = this.jobs[key];
            }
        }
        if (this.stationUse && this.stationUse.constructor === Array) {
            data["stationUse"] = [];
            for (let item of this.stationUse)
                data["stationUse"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHistoricData extends IValueType {
    jobs: { [key: string] : JobPlan; };
    stationUse: SimulatedStationUtilization[];
}

export class JobPlan implements IJobPlan {
    routeStartUTC: Date;
    routeEndUTC: Date;
    archived: boolean;
    copiedToSystem: boolean;
    partName: string;
    comment?: string;
    unique: string;
    priority: number;
    scheduleId?: string;
    bookings?: string[];
    manuallyCreated: boolean;
    createMarkingData: boolean;
    inspections?: JobInspectionData[];
    holdEntireJob: JobHoldPattern = new JobHoldPattern();
    cyclesOnFirstProcess: number[] = [];
    procsAndPaths: ProcPathInfo[][] = [];

    constructor(data?: IJobPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.routeStartUTC = data["routeStartUTC"] ? new Date(data["routeStartUTC"].toString()) : <any>undefined;
            this.routeEndUTC = data["routeEndUTC"] ? new Date(data["routeEndUTC"].toString()) : <any>undefined;
            this.archived = data["archived"];
            this.copiedToSystem = data["copiedToSystem"];
            this.partName = data["partName"];
            this.comment = data["comment"];
            this.unique = data["unique"];
            this.priority = data["priority"];
            this.scheduleId = data["scheduleId"];
            if (data["bookings"] && data["bookings"].constructor === Array) {
                this.bookings = [];
                for (let item of data["bookings"])
                    this.bookings.push(item);
            }
            this.manuallyCreated = data["manuallyCreated"];
            this.createMarkingData = data["createMarkingData"];
            if (data["inspections"] && data["inspections"].constructor === Array) {
                this.inspections = [];
                for (let item of data["inspections"])
                    this.inspections.push(JobInspectionData.fromJS(item));
            }
            this.holdEntireJob = data["holdEntireJob"] ? JobHoldPattern.fromJS(data["holdEntireJob"]) : new JobHoldPattern();
            if (data["cyclesOnFirstProcess"] && data["cyclesOnFirstProcess"].constructor === Array) {
                this.cyclesOnFirstProcess = [];
                for (let item of data["cyclesOnFirstProcess"])
                    this.cyclesOnFirstProcess.push(item);
            }
            if (data["procsAndPaths"] && data["procsAndPaths"].constructor === Array) {
                this.procsAndPaths = [];
                for (let item of data["procsAndPaths"])
                    this.procsAndPaths.push(item);
            }
        }
    }

    static fromJS(data: any): JobPlan {
        data = typeof data === 'object' ? data : {};
        let result = new JobPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["routeStartUTC"] = this.routeStartUTC ? this.routeStartUTC.toISOString() : <any>undefined;
        data["routeEndUTC"] = this.routeEndUTC ? this.routeEndUTC.toISOString() : <any>undefined;
        data["archived"] = this.archived;
        data["copiedToSystem"] = this.copiedToSystem;
        data["partName"] = this.partName;
        data["comment"] = this.comment;
        data["unique"] = this.unique;
        data["priority"] = this.priority;
        data["scheduleId"] = this.scheduleId;
        if (this.bookings && this.bookings.constructor === Array) {
            data["bookings"] = [];
            for (let item of this.bookings)
                data["bookings"].push(item);
        }
        data["manuallyCreated"] = this.manuallyCreated;
        data["createMarkingData"] = this.createMarkingData;
        if (this.inspections && this.inspections.constructor === Array) {
            data["inspections"] = [];
            for (let item of this.inspections)
                data["inspections"].push(item.toJSON());
        }
        data["holdEntireJob"] = this.holdEntireJob ? this.holdEntireJob.toJSON() : <any>undefined;
        if (this.cyclesOnFirstProcess && this.cyclesOnFirstProcess.constructor === Array) {
            data["cyclesOnFirstProcess"] = [];
            for (let item of this.cyclesOnFirstProcess)
                data["cyclesOnFirstProcess"].push(item);
        }
        if (this.procsAndPaths && this.procsAndPaths.constructor === Array) {
            data["procsAndPaths"] = [];
            for (let item of this.procsAndPaths)
                data["procsAndPaths"].push(item);
        }
        return data;
    }
}

export interface IJobPlan {
    routeStartUTC: Date;
    routeEndUTC: Date;
    archived: boolean;
    copiedToSystem: boolean;
    partName: string;
    comment?: string;
    unique: string;
    priority: number;
    scheduleId?: string;
    bookings?: string[];
    manuallyCreated: boolean;
    createMarkingData: boolean;
    inspections?: JobInspectionData[];
    holdEntireJob: JobHoldPattern;
    cyclesOnFirstProcess: number[];
    procsAndPaths: ProcPathInfo[][];
}

export class JobInspectionData implements IJobInspectionData {
    inspectionType: string;
    counter: string;
    maxVal: number;
    randomFreq: number;
    timeInterval: string;
    inspectSingleProcess: number;

    constructor(data?: IJobInspectionData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inspectionType = data["inspectionType"];
            this.counter = data["counter"];
            this.maxVal = data["maxVal"];
            this.randomFreq = data["randomFreq"];
            this.timeInterval = data["timeInterval"];
            this.inspectSingleProcess = data["inspectSingleProcess"];
        }
    }

    static fromJS(data: any): JobInspectionData {
        data = typeof data === 'object' ? data : {};
        let result = new JobInspectionData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspectionType"] = this.inspectionType;
        data["counter"] = this.counter;
        data["maxVal"] = this.maxVal;
        data["randomFreq"] = this.randomFreq;
        data["timeInterval"] = this.timeInterval;
        data["inspectSingleProcess"] = this.inspectSingleProcess;
        return data;
    }
}

export interface IJobInspectionData {
    inspectionType: string;
    counter: string;
    maxVal: number;
    randomFreq: number;
    timeInterval: string;
    inspectSingleProcess: number;
}

export class JobHoldPattern implements IJobHoldPattern {
    userHold: boolean;
    reasonForUserHold: string;
    holdUnholdPattern: string[] = [];
    holdUnholdPatternStartUTC: Date;
    holdUnholdPatternRepeats: boolean;

    constructor(data?: IJobHoldPattern) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userHold = data["userHold"];
            this.reasonForUserHold = data["reasonForUserHold"];
            if (data["holdUnholdPattern"] && data["holdUnholdPattern"].constructor === Array) {
                this.holdUnholdPattern = [];
                for (let item of data["holdUnholdPattern"])
                    this.holdUnholdPattern.push(item);
            }
            this.holdUnholdPatternStartUTC = data["holdUnholdPatternStartUTC"] ? new Date(data["holdUnholdPatternStartUTC"].toString()) : <any>undefined;
            this.holdUnholdPatternRepeats = data["holdUnholdPatternRepeats"];
        }
    }

    static fromJS(data: any): JobHoldPattern {
        data = typeof data === 'object' ? data : {};
        let result = new JobHoldPattern();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userHold"] = this.userHold;
        data["reasonForUserHold"] = this.reasonForUserHold;
        if (this.holdUnholdPattern && this.holdUnholdPattern.constructor === Array) {
            data["holdUnholdPattern"] = [];
            for (let item of this.holdUnholdPattern)
                data["holdUnholdPattern"].push(item);
        }
        data["holdUnholdPatternStartUTC"] = this.holdUnholdPatternStartUTC ? this.holdUnholdPatternStartUTC.toISOString() : <any>undefined;
        data["holdUnholdPatternRepeats"] = this.holdUnholdPatternRepeats;
        return data;
    }
}

export interface IJobHoldPattern {
    userHold: boolean;
    reasonForUserHold: string;
    holdUnholdPattern: string[];
    holdUnholdPatternStartUTC: Date;
    holdUnholdPatternRepeats: boolean;
}

export class ProcPathInfo extends ValueType implements IProcPathInfo {
    pathGroup: number;
    pallets: string[] = [];
    fixtures?: FixtureFace[];
    load: number[] = [];
    unload: number[] = [];
    stops: JobMachiningStop[] = [];
    simulatedProduction?: SimulatedProduction[];
    simulatedStartingUTC: Date;
    simulatedAverageFlowTime: string;
    holdMachining: JobHoldPattern = new JobHoldPattern();
    holdLoadUnload: JobHoldPattern = new JobHoldPattern();
    partsPerPallet: number;
    inputQueue?: string;
    outputQueue?: string;

    constructor(data?: IProcPathInfo) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pathGroup = data["pathGroup"];
            if (data["pallets"] && data["pallets"].constructor === Array) {
                this.pallets = [];
                for (let item of data["pallets"])
                    this.pallets.push(item);
            }
            if (data["fixtures"] && data["fixtures"].constructor === Array) {
                this.fixtures = [];
                for (let item of data["fixtures"])
                    this.fixtures.push(FixtureFace.fromJS(item));
            }
            if (data["load"] && data["load"].constructor === Array) {
                this.load = [];
                for (let item of data["load"])
                    this.load.push(item);
            }
            if (data["unload"] && data["unload"].constructor === Array) {
                this.unload = [];
                for (let item of data["unload"])
                    this.unload.push(item);
            }
            if (data["stops"] && data["stops"].constructor === Array) {
                this.stops = [];
                for (let item of data["stops"])
                    this.stops.push(JobMachiningStop.fromJS(item));
            }
            if (data["simulatedProduction"] && data["simulatedProduction"].constructor === Array) {
                this.simulatedProduction = [];
                for (let item of data["simulatedProduction"])
                    this.simulatedProduction.push(SimulatedProduction.fromJS(item));
            }
            this.simulatedStartingUTC = data["simulatedStartingUTC"] ? new Date(data["simulatedStartingUTC"].toString()) : <any>undefined;
            this.simulatedAverageFlowTime = data["simulatedAverageFlowTime"];
            this.holdMachining = data["holdMachining"] ? JobHoldPattern.fromJS(data["holdMachining"]) : new JobHoldPattern();
            this.holdLoadUnload = data["holdLoadUnload"] ? JobHoldPattern.fromJS(data["holdLoadUnload"]) : new JobHoldPattern();
            this.partsPerPallet = data["partsPerPallet"];
            this.inputQueue = data["inputQueue"];
            this.outputQueue = data["outputQueue"];
        }
    }

    static fromJS(data: any): ProcPathInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ProcPathInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pathGroup"] = this.pathGroup;
        if (this.pallets && this.pallets.constructor === Array) {
            data["pallets"] = [];
            for (let item of this.pallets)
                data["pallets"].push(item);
        }
        if (this.fixtures && this.fixtures.constructor === Array) {
            data["fixtures"] = [];
            for (let item of this.fixtures)
                data["fixtures"].push(item.toJSON());
        }
        if (this.load && this.load.constructor === Array) {
            data["load"] = [];
            for (let item of this.load)
                data["load"].push(item);
        }
        if (this.unload && this.unload.constructor === Array) {
            data["unload"] = [];
            for (let item of this.unload)
                data["unload"].push(item);
        }
        if (this.stops && this.stops.constructor === Array) {
            data["stops"] = [];
            for (let item of this.stops)
                data["stops"].push(item.toJSON());
        }
        if (this.simulatedProduction && this.simulatedProduction.constructor === Array) {
            data["simulatedProduction"] = [];
            for (let item of this.simulatedProduction)
                data["simulatedProduction"].push(item.toJSON());
        }
        data["simulatedStartingUTC"] = this.simulatedStartingUTC ? this.simulatedStartingUTC.toISOString() : <any>undefined;
        data["simulatedAverageFlowTime"] = this.simulatedAverageFlowTime;
        data["holdMachining"] = this.holdMachining ? this.holdMachining.toJSON() : <any>undefined;
        data["holdLoadUnload"] = this.holdLoadUnload ? this.holdLoadUnload.toJSON() : <any>undefined;
        data["partsPerPallet"] = this.partsPerPallet;
        data["inputQueue"] = this.inputQueue;
        data["outputQueue"] = this.outputQueue;
        super.toJSON(data);
        return data;
    }
}

export interface IProcPathInfo extends IValueType {
    pathGroup: number;
    pallets: string[];
    fixtures?: FixtureFace[];
    load: number[];
    unload: number[];
    stops: JobMachiningStop[];
    simulatedProduction?: SimulatedProduction[];
    simulatedStartingUTC: Date;
    simulatedAverageFlowTime: string;
    holdMachining: JobHoldPattern;
    holdLoadUnload: JobHoldPattern;
    partsPerPallet: number;
    inputQueue?: string;
    outputQueue?: string;
}

export class FixtureFace extends ValueType implements IFixtureFace {
    fixture: string;
    face: string;

    constructor(data?: IFixtureFace) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.fixture = data["fixture"];
            this.face = data["face"];
        }
    }

    static fromJS(data: any): FixtureFace {
        data = typeof data === 'object' ? data : {};
        let result = new FixtureFace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixture"] = this.fixture;
        data["face"] = this.face;
        super.toJSON(data);
        return data;
    }
}

export interface IFixtureFace extends IValueType {
    fixture: string;
    face: string;
}

export class JobMachiningStop implements IJobMachiningStop {
    stations: { [key: string] : string; } = {};
    tools: { [key: string] : string; } = {};
    stationGroup: string;
    expectedCycleTime: string;

    constructor(data?: IJobMachiningStop) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stations"]) {
                this.stations = {};
                for (let key in data["stations"]) {
                    if (data["stations"].hasOwnProperty(key))
                        this.stations[key] = data["stations"][key];
                }
            }
            if (data["tools"]) {
                this.tools = {};
                for (let key in data["tools"]) {
                    if (data["tools"].hasOwnProperty(key))
                        this.tools[key] = data["tools"][key];
                }
            }
            this.stationGroup = data["stationGroup"];
            this.expectedCycleTime = data["expectedCycleTime"];
        }
    }

    static fromJS(data: any): JobMachiningStop {
        data = typeof data === 'object' ? data : {};
        let result = new JobMachiningStop();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stations) {
            data["stations"] = {};
            for (let key in this.stations) {
                if (this.stations.hasOwnProperty(key))
                    data["stations"][key] = this.stations[key];
            }
        }
        if (this.tools) {
            data["tools"] = {};
            for (let key in this.tools) {
                if (this.tools.hasOwnProperty(key))
                    data["tools"][key] = this.tools[key];
            }
        }
        data["stationGroup"] = this.stationGroup;
        data["expectedCycleTime"] = this.expectedCycleTime;
        return data;
    }
}

export interface IJobMachiningStop {
    stations: { [key: string] : string; };
    tools: { [key: string] : string; };
    stationGroup: string;
    expectedCycleTime: string;
}

export class SimulatedProduction extends ValueType implements ISimulatedProduction {
    timeUTC: Date;
    quantity: number;

    constructor(data?: ISimulatedProduction) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.timeUTC = data["timeUTC"] ? new Date(data["timeUTC"].toString()) : <any>undefined;
            this.quantity = data["quantity"];
        }
    }

    static fromJS(data: any): SimulatedProduction {
        data = typeof data === 'object' ? data : {};
        let result = new SimulatedProduction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeUTC"] = this.timeUTC ? this.timeUTC.toISOString() : <any>undefined;
        data["quantity"] = this.quantity;
        super.toJSON(data);
        return data;
    }
}

export interface ISimulatedProduction extends IValueType {
    timeUTC: Date;
    quantity: number;
}

export class SimulatedStationUtilization implements ISimulatedStationUtilization {
    simulationId: string;
    stationGroup: string;
    stationNum: number;
    startUTC: Date;
    endUTC: Date;
    utilizationTime: string;
    plannedDownTime: string;

    constructor(data?: ISimulatedStationUtilization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.simulationId = data["simulationId"];
            this.stationGroup = data["stationGroup"];
            this.stationNum = data["stationNum"];
            this.startUTC = data["startUTC"] ? new Date(data["startUTC"].toString()) : <any>undefined;
            this.endUTC = data["endUTC"] ? new Date(data["endUTC"].toString()) : <any>undefined;
            this.utilizationTime = data["utilizationTime"];
            this.plannedDownTime = data["plannedDownTime"];
        }
    }

    static fromJS(data: any): SimulatedStationUtilization {
        data = typeof data === 'object' ? data : {};
        let result = new SimulatedStationUtilization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["simulationId"] = this.simulationId;
        data["stationGroup"] = this.stationGroup;
        data["stationNum"] = this.stationNum;
        data["startUTC"] = this.startUTC ? this.startUTC.toISOString() : <any>undefined;
        data["endUTC"] = this.endUTC ? this.endUTC.toISOString() : <any>undefined;
        data["utilizationTime"] = this.utilizationTime;
        data["plannedDownTime"] = this.plannedDownTime;
        return data;
    }
}

export interface ISimulatedStationUtilization {
    simulationId: string;
    stationGroup: string;
    stationNum: number;
    startUTC: Date;
    endUTC: Date;
    utilizationTime: string;
    plannedDownTime: string;
}

export class JobsAndExtraParts extends ValueType implements IJobsAndExtraParts {
    latestScheduleId: string;
    jobs: JobPlan[] = [];
    extraParts: { [key: string] : number; } = {};
    currentUnfilledWorkorders?: PartWorkorder[];

    constructor(data?: IJobsAndExtraParts) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.latestScheduleId = data["latestScheduleId"];
            if (data["jobs"] && data["jobs"].constructor === Array) {
                this.jobs = [];
                for (let item of data["jobs"])
                    this.jobs.push(JobPlan.fromJS(item));
            }
            if (data["extraParts"]) {
                this.extraParts = {};
                for (let key in data["extraParts"]) {
                    if (data["extraParts"].hasOwnProperty(key))
                        this.extraParts[key] = data["extraParts"][key];
                }
            }
            if (data["currentUnfilledWorkorders"] && data["currentUnfilledWorkorders"].constructor === Array) {
                this.currentUnfilledWorkorders = [];
                for (let item of data["currentUnfilledWorkorders"])
                    this.currentUnfilledWorkorders.push(PartWorkorder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): JobsAndExtraParts {
        data = typeof data === 'object' ? data : {};
        let result = new JobsAndExtraParts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["latestScheduleId"] = this.latestScheduleId;
        if (this.jobs && this.jobs.constructor === Array) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        if (this.extraParts) {
            data["extraParts"] = {};
            for (let key in this.extraParts) {
                if (this.extraParts.hasOwnProperty(key))
                    data["extraParts"][key] = this.extraParts[key];
            }
        }
        if (this.currentUnfilledWorkorders && this.currentUnfilledWorkorders.constructor === Array) {
            data["currentUnfilledWorkorders"] = [];
            for (let item of this.currentUnfilledWorkorders)
                data["currentUnfilledWorkorders"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IJobsAndExtraParts extends IValueType {
    latestScheduleId: string;
    jobs: JobPlan[];
    extraParts: { [key: string] : number; };
    currentUnfilledWorkorders?: PartWorkorder[];
}

export class PartWorkorder implements IPartWorkorder {
    workorderId: string;
    part: string;
    quantity: number;
    dueDate: Date;
    priority: number;

    constructor(data?: IPartWorkorder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workorderId = data["workorderId"];
            this.part = data["part"];
            this.quantity = data["quantity"];
            this.dueDate = data["dueDate"] ? new Date(data["dueDate"].toString()) : <any>undefined;
            this.priority = data["priority"];
        }
    }

    static fromJS(data: any): PartWorkorder {
        data = typeof data === 'object' ? data : {};
        let result = new PartWorkorder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workorderId"] = this.workorderId;
        data["part"] = this.part;
        data["quantity"] = this.quantity;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["priority"] = this.priority;
        return data;
    }
}

export interface IPartWorkorder {
    workorderId: string;
    part: string;
    quantity: number;
    dueDate: Date;
    priority: number;
}

export class CurrentStatus implements ICurrentStatus {
    jobs: { [key: string] : InProcessJob; } = {};
    pallets: { [key: string] : PalletStatus; } = {};
    material: InProcessMaterial[] = [];
    alarms?: string[];
    latestScheduleId?: string;

    constructor(data?: ICurrentStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["jobs"]) {
                this.jobs = {};
                for (let key in data["jobs"]) {
                    if (data["jobs"].hasOwnProperty(key))
                        this.jobs[key] = data["jobs"][key] ? InProcessJob.fromJS(data["jobs"][key]) : new InProcessJob();
                }
            }
            if (data["pallets"]) {
                this.pallets = {};
                for (let key in data["pallets"]) {
                    if (data["pallets"].hasOwnProperty(key))
                        this.pallets[key] = data["pallets"][key] ? PalletStatus.fromJS(data["pallets"][key]) : new PalletStatus();
                }
            }
            if (data["material"] && data["material"].constructor === Array) {
                this.material = [];
                for (let item of data["material"])
                    this.material.push(InProcessMaterial.fromJS(item));
            }
            if (data["alarms"] && data["alarms"].constructor === Array) {
                this.alarms = [];
                for (let item of data["alarms"])
                    this.alarms.push(item);
            }
            this.latestScheduleId = data["latestScheduleId"];
        }
    }

    static fromJS(data: any): CurrentStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.jobs) {
            data["jobs"] = {};
            for (let key in this.jobs) {
                if (this.jobs.hasOwnProperty(key))
                    data["jobs"][key] = this.jobs[key];
            }
        }
        if (this.pallets) {
            data["pallets"] = {};
            for (let key in this.pallets) {
                if (this.pallets.hasOwnProperty(key))
                    data["pallets"][key] = this.pallets[key];
            }
        }
        if (this.material && this.material.constructor === Array) {
            data["material"] = [];
            for (let item of this.material)
                data["material"].push(item.toJSON());
        }
        if (this.alarms && this.alarms.constructor === Array) {
            data["alarms"] = [];
            for (let item of this.alarms)
                data["alarms"].push(item);
        }
        data["latestScheduleId"] = this.latestScheduleId;
        return data;
    }
}

export interface ICurrentStatus {
    jobs: { [key: string] : InProcessJob; };
    pallets: { [key: string] : PalletStatus; };
    material: InProcessMaterial[];
    alarms?: string[];
    latestScheduleId?: string;
}

export class InProcessJob extends JobPlan implements IInProcessJob {
    completedProc1: number[] = [];
    totalCompleteOnFinalProcess: number;

    constructor(data?: IInProcessJob) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["completedProc1"] && data["completedProc1"].constructor === Array) {
                this.completedProc1 = [];
                for (let item of data["completedProc1"])
                    this.completedProc1.push(item);
            }
            this.totalCompleteOnFinalProcess = data["totalCompleteOnFinalProcess"];
        }
    }

    static fromJS(data: any): InProcessJob {
        data = typeof data === 'object' ? data : {};
        let result = new InProcessJob();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.completedProc1 && this.completedProc1.constructor === Array) {
            data["completedProc1"] = [];
            for (let item of this.completedProc1)
                data["completedProc1"].push(item);
        }
        data["totalCompleteOnFinalProcess"] = this.totalCompleteOnFinalProcess;
        super.toJSON(data);
        return data;
    }
}

export interface IInProcessJob extends IJobPlan {
    completedProc1: number[];
    totalCompleteOnFinalProcess: number;
}

export class PalletStatus implements IPalletStatus {
    pallet: string;
    fixtureOnPallet: string;
    onHold: boolean;
    currentPalletLocation: PalletLocation = new PalletLocation();
    newFixture?: string;
    targetLocation?: PalletLocation;
    percentMoveCompleted?: number;

    constructor(data?: IPalletStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pallet = data["pallet"];
            this.fixtureOnPallet = data["fixtureOnPallet"];
            this.onHold = data["onHold"];
            this.currentPalletLocation = data["currentPalletLocation"] ? PalletLocation.fromJS(data["currentPalletLocation"]) : new PalletLocation();
            this.newFixture = data["newFixture"];
            this.targetLocation = data["targetLocation"] ? PalletLocation.fromJS(data["targetLocation"]) : <any>undefined;
            this.percentMoveCompleted = data["percentMoveCompleted"];
        }
    }

    static fromJS(data: any): PalletStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PalletStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pallet"] = this.pallet;
        data["fixtureOnPallet"] = this.fixtureOnPallet;
        data["onHold"] = this.onHold;
        data["currentPalletLocation"] = this.currentPalletLocation ? this.currentPalletLocation.toJSON() : <any>undefined;
        data["newFixture"] = this.newFixture;
        data["targetLocation"] = this.targetLocation ? this.targetLocation.toJSON() : <any>undefined;
        data["percentMoveCompleted"] = this.percentMoveCompleted;
        return data;
    }
}

export interface IPalletStatus {
    pallet: string;
    fixtureOnPallet: string;
    onHold: boolean;
    currentPalletLocation: PalletLocation;
    newFixture?: string;
    targetLocation?: PalletLocation;
    percentMoveCompleted?: number;
}

export class PalletLocation extends ValueType implements IPalletLocation {
    loc: PalletLocationEnum;
    num: number;

    constructor(data?: IPalletLocation) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.loc = data["loc"];
            this.num = data["num"];
        }
    }

    static fromJS(data: any): PalletLocation {
        data = typeof data === 'object' ? data : {};
        let result = new PalletLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loc"] = this.loc;
        data["num"] = this.num;
        super.toJSON(data);
        return data;
    }
}

export interface IPalletLocation extends IValueType {
    loc: PalletLocationEnum;
    num: number;
}

export class InProcessMaterial implements IInProcessMaterial {
    materialID: number;
    jobUnique: string;
    partName: string;
    process: number;
    path: number;
    location: InProcessMaterialLocation = new InProcessMaterialLocation();
    action: InProcessMaterialAction = new InProcessMaterialAction();

    constructor(data?: IInProcessMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialID = data["materialID"];
            this.jobUnique = data["jobUnique"];
            this.partName = data["partName"];
            this.process = data["process"];
            this.path = data["path"];
            this.location = data["location"] ? InProcessMaterialLocation.fromJS(data["location"]) : new InProcessMaterialLocation();
            this.action = data["action"] ? InProcessMaterialAction.fromJS(data["action"]) : new InProcessMaterialAction();
        }
    }

    static fromJS(data: any): InProcessMaterial {
        data = typeof data === 'object' ? data : {};
        let result = new InProcessMaterial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialID"] = this.materialID;
        data["jobUnique"] = this.jobUnique;
        data["partName"] = this.partName;
        data["process"] = this.process;
        data["path"] = this.path;
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInProcessMaterial {
    materialID: number;
    jobUnique: string;
    partName: string;
    process: number;
    path: number;
    location: InProcessMaterialLocation;
    action: InProcessMaterialAction;
}

export class InProcessMaterialLocation implements IInProcessMaterialLocation {
    type: LocType;
    pallet?: string;
    fixture?: string;
    face: number;
    currentQueue?: string;

    constructor(data?: IInProcessMaterialLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.pallet = data["pallet"];
            this.fixture = data["fixture"];
            this.face = data["face"];
            this.currentQueue = data["currentQueue"];
        }
    }

    static fromJS(data: any): InProcessMaterialLocation {
        data = typeof data === 'object' ? data : {};
        let result = new InProcessMaterialLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["pallet"] = this.pallet;
        data["fixture"] = this.fixture;
        data["face"] = this.face;
        data["currentQueue"] = this.currentQueue;
        return data;
    }
}

export interface IInProcessMaterialLocation {
    type: LocType;
    pallet?: string;
    fixture?: string;
    face: number;
    currentQueue?: string;
}

export enum LocType {
    Free = <any>"Free",
    OnPallet = <any>"OnPallet",
    InQueue = <any>"InQueue",
}

export class InProcessMaterialAction implements IInProcessMaterialAction {
    type: ActionType;
    loadOntoPallet?: string;
    loadOntoFace: number;
    unloadIntoQueue?: string;
    program?: string;
    elapsedMachiningTime?: string;
    expectedRemainingMachiningTime?: string;

    constructor(data?: IInProcessMaterialAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.loadOntoPallet = data["loadOntoPallet"];
            this.loadOntoFace = data["loadOntoFace"];
            this.unloadIntoQueue = data["unloadIntoQueue"];
            this.program = data["program"];
            this.elapsedMachiningTime = data["elapsedMachiningTime"];
            this.expectedRemainingMachiningTime = data["expectedRemainingMachiningTime"];
        }
    }

    static fromJS(data: any): InProcessMaterialAction {
        data = typeof data === 'object' ? data : {};
        let result = new InProcessMaterialAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["loadOntoPallet"] = this.loadOntoPallet;
        data["loadOntoFace"] = this.loadOntoFace;
        data["unloadIntoQueue"] = this.unloadIntoQueue;
        data["program"] = this.program;
        data["elapsedMachiningTime"] = this.elapsedMachiningTime;
        data["expectedRemainingMachiningTime"] = this.expectedRemainingMachiningTime;
        return data;
    }
}

export interface IInProcessMaterialAction {
    type: ActionType;
    loadOntoPallet?: string;
    loadOntoFace: number;
    unloadIntoQueue?: string;
    program?: string;
    elapsedMachiningTime?: string;
    expectedRemainingMachiningTime?: string;
}

export enum ActionType {
    Waiting = <any>"Waiting",
    Loading = <any>"Loading",
    Unloading = <any>"Unloading",
    Machining = <any>"Machining",
}

export class NewJobs extends ValueType implements INewJobs {
    scheduleId: string;
    jobs: JobPlan[] = [];
    stationUse: SimulatedStationUtilization[] = [];
    extraParts: { [key: string] : number; } = {};
    archiveCompletedJobs: boolean;
    debugMessage?: string;
    currentUnfilledWorkorders?: PartWorkorder[];
    queueSizes?: { [key: string] : QueueSize; };

    constructor(data?: INewJobs) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.scheduleId = data["scheduleId"];
            if (data["jobs"] && data["jobs"].constructor === Array) {
                this.jobs = [];
                for (let item of data["jobs"])
                    this.jobs.push(JobPlan.fromJS(item));
            }
            if (data["stationUse"] && data["stationUse"].constructor === Array) {
                this.stationUse = [];
                for (let item of data["stationUse"])
                    this.stationUse.push(SimulatedStationUtilization.fromJS(item));
            }
            if (data["extraParts"]) {
                this.extraParts = {};
                for (let key in data["extraParts"]) {
                    if (data["extraParts"].hasOwnProperty(key))
                        this.extraParts[key] = data["extraParts"][key];
                }
            }
            this.archiveCompletedJobs = data["archiveCompletedJobs"];
            this.debugMessage = data["debugMessage"];
            if (data["currentUnfilledWorkorders"] && data["currentUnfilledWorkorders"].constructor === Array) {
                this.currentUnfilledWorkorders = [];
                for (let item of data["currentUnfilledWorkorders"])
                    this.currentUnfilledWorkorders.push(PartWorkorder.fromJS(item));
            }
            if (data["queueSizes"]) {
                this.queueSizes = {};
                for (let key in data["queueSizes"]) {
                    if (data["queueSizes"].hasOwnProperty(key))
                        this.queueSizes[key] = data["queueSizes"][key] ? QueueSize.fromJS(data["queueSizes"][key]) : new QueueSize();
                }
            }
        }
    }

    static fromJS(data: any): NewJobs {
        data = typeof data === 'object' ? data : {};
        let result = new NewJobs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleId"] = this.scheduleId;
        if (this.jobs && this.jobs.constructor === Array) {
            data["jobs"] = [];
            for (let item of this.jobs)
                data["jobs"].push(item.toJSON());
        }
        if (this.stationUse && this.stationUse.constructor === Array) {
            data["stationUse"] = [];
            for (let item of this.stationUse)
                data["stationUse"].push(item.toJSON());
        }
        if (this.extraParts) {
            data["extraParts"] = {};
            for (let key in this.extraParts) {
                if (this.extraParts.hasOwnProperty(key))
                    data["extraParts"][key] = this.extraParts[key];
            }
        }
        data["archiveCompletedJobs"] = this.archiveCompletedJobs;
        data["debugMessage"] = this.debugMessage;
        if (this.currentUnfilledWorkorders && this.currentUnfilledWorkorders.constructor === Array) {
            data["currentUnfilledWorkorders"] = [];
            for (let item of this.currentUnfilledWorkorders)
                data["currentUnfilledWorkorders"].push(item.toJSON());
        }
        if (this.queueSizes) {
            data["queueSizes"] = {};
            for (let key in this.queueSizes) {
                if (this.queueSizes.hasOwnProperty(key))
                    data["queueSizes"][key] = this.queueSizes[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface INewJobs extends IValueType {
    scheduleId: string;
    jobs: JobPlan[];
    stationUse: SimulatedStationUtilization[];
    extraParts: { [key: string] : number; };
    archiveCompletedJobs: boolean;
    debugMessage?: string;
    currentUnfilledWorkorders?: PartWorkorder[];
    queueSizes?: { [key: string] : QueueSize; };
}

export class QueueSize extends ValueType implements IQueueSize {
    maxSizeBeforeStopLoading: number;
    maxSizeBeforeStopUnloading: number;

    constructor(data?: IQueueSize) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.maxSizeBeforeStopLoading = data["maxSizeBeforeStopLoading"];
            this.maxSizeBeforeStopUnloading = data["maxSizeBeforeStopUnloading"];
        }
    }

    static fromJS(data: any): QueueSize {
        data = typeof data === 'object' ? data : {};
        let result = new QueueSize();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxSizeBeforeStopLoading"] = this.maxSizeBeforeStopLoading;
        data["maxSizeBeforeStopUnloading"] = this.maxSizeBeforeStopUnloading;
        super.toJSON(data);
        return data;
    }
}

export interface IQueueSize extends IValueType {
    maxSizeBeforeStopLoading: number;
    maxSizeBeforeStopUnloading: number;
}

export class JobAndDecrementQuantity extends ValueType implements IJobAndDecrementQuantity {
    decrementId: string;
    jobUnique: string;
    timeUTC: Date;
    part: string;
    quantity: number;

    constructor(data?: IJobAndDecrementQuantity) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.decrementId = data["decrementId"];
            this.jobUnique = data["jobUnique"];
            this.timeUTC = data["timeUTC"] ? new Date(data["timeUTC"].toString()) : <any>undefined;
            this.part = data["part"];
            this.quantity = data["quantity"];
        }
    }

    static fromJS(data: any): JobAndDecrementQuantity {
        data = typeof data === 'object' ? data : {};
        let result = new JobAndDecrementQuantity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["decrementId"] = this.decrementId;
        data["jobUnique"] = this.jobUnique;
        data["timeUTC"] = this.timeUTC ? this.timeUTC.toISOString() : <any>undefined;
        data["part"] = this.part;
        data["quantity"] = this.quantity;
        super.toJSON(data);
        return data;
    }
}

export interface IJobAndDecrementQuantity extends IValueType {
    decrementId: string;
    jobUnique: string;
    timeUTC: Date;
    part: string;
    quantity: number;
}

export class LogEntry implements ILogEntry {
    details?: { [key: string] : string; };
    counter: number;
    material: LogMaterial[] = [];
    type: LogType;
    startofcycle: boolean;
    endUTC: Date;
    loc: string;
    locnum: number;
    pal: string;
    program: string;
    result: string;
    endofroute: boolean;
    elapsed: string;
    active: string;

    constructor(data?: ILogEntry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["details"]) {
                this.details = {};
                for (let key in data["details"]) {
                    if (data["details"].hasOwnProperty(key))
                        this.details[key] = data["details"][key];
                }
            }
            this.counter = data["counter"];
            if (data["material"] && data["material"].constructor === Array) {
                this.material = [];
                for (let item of data["material"])
                    this.material.push(LogMaterial.fromJS(item));
            }
            this.type = data["type"];
            this.startofcycle = data["startofcycle"];
            this.endUTC = data["endUTC"] ? new Date(data["endUTC"].toString()) : <any>undefined;
            this.loc = data["loc"];
            this.locnum = data["locnum"];
            this.pal = data["pal"];
            this.program = data["program"];
            this.result = data["result"];
            this.endofroute = data["endofroute"];
            this.elapsed = data["elapsed"];
            this.active = data["active"];
        }
    }

    static fromJS(data: any): LogEntry {
        data = typeof data === 'object' ? data : {};
        let result = new LogEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.details) {
            data["details"] = {};
            for (let key in this.details) {
                if (this.details.hasOwnProperty(key))
                    data["details"][key] = this.details[key];
            }
        }
        data["counter"] = this.counter;
        if (this.material && this.material.constructor === Array) {
            data["material"] = [];
            for (let item of this.material)
                data["material"].push(item.toJSON());
        }
        data["type"] = this.type;
        data["startofcycle"] = this.startofcycle;
        data["endUTC"] = this.endUTC ? this.endUTC.toISOString() : <any>undefined;
        data["loc"] = this.loc;
        data["locnum"] = this.locnum;
        data["pal"] = this.pal;
        data["program"] = this.program;
        data["result"] = this.result;
        data["endofroute"] = this.endofroute;
        data["elapsed"] = this.elapsed;
        data["active"] = this.active;
        return data;
    }
}

export interface ILogEntry {
    details?: { [key: string] : string; };
    counter: number;
    material: LogMaterial[];
    type: LogType;
    startofcycle: boolean;
    endUTC: Date;
    loc: string;
    locnum: number;
    pal: string;
    program: string;
    result: string;
    endofroute: boolean;
    elapsed: string;
    active: string;
}

export class LogMaterial implements ILogMaterial {
    id: number;
    uniq: string;
    part: string;
    proc: number;
    numproc: number;
    face: string;

    constructor(data?: ILogMaterial) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.uniq = data["uniq"];
            this.part = data["part"];
            this.proc = data["proc"];
            this.numproc = data["numproc"];
            this.face = data["face"];
        }
    }

    static fromJS(data: any): LogMaterial {
        data = typeof data === 'object' ? data : {};
        let result = new LogMaterial();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uniq"] = this.uniq;
        data["part"] = this.part;
        data["proc"] = this.proc;
        data["numproc"] = this.numproc;
        data["face"] = this.face;
        return data;
    }
}

export interface ILogMaterial {
    id: number;
    uniq: string;
    part: string;
    proc: number;
    numproc: number;
    face: string;
}

export enum LogType {
    LoadUnloadCycle = <any>"LoadUnloadCycle",
    MachineCycle = <any>"MachineCycle",
    PartMark = <any>"PartMark",
    Inspection = <any>"Inspection",
    OrderAssignment = <any>"OrderAssignment",
    GeneralMessage = <any>"GeneralMessage",
    PalletCycle = <any>"PalletCycle",
    FinalizeWorkorder = <any>"FinalizeWorkorder",
}

export class WorkorderSummary implements IWorkorderSummary {
    parts: WorkorderPartSummary[] = [];
    serials: string[] = [];
    id: string;
    finalized?: Date;

    constructor(data?: IWorkorderSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["parts"] && data["parts"].constructor === Array) {
                this.parts = [];
                for (let item of data["parts"])
                    this.parts.push(WorkorderPartSummary.fromJS(item));
            }
            if (data["serials"] && data["serials"].constructor === Array) {
                this.serials = [];
                for (let item of data["serials"])
                    this.serials.push(item);
            }
            this.id = data["id"];
            this.finalized = data["finalized"] ? new Date(data["finalized"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WorkorderSummary {
        data = typeof data === 'object' ? data : {};
        let result = new WorkorderSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.parts && this.parts.constructor === Array) {
            data["parts"] = [];
            for (let item of this.parts)
                data["parts"].push(item.toJSON());
        }
        if (this.serials && this.serials.constructor === Array) {
            data["serials"] = [];
            for (let item of this.serials)
                data["serials"].push(item);
        }
        data["id"] = this.id;
        data["finalized"] = this.finalized ? this.finalized.toISOString() : <any>undefined;
        return data;
    }
}

export interface IWorkorderSummary {
    parts: WorkorderPartSummary[];
    serials: string[];
    id: string;
    finalized?: Date;
}

export class WorkorderPartSummary implements IWorkorderPartSummary {
    elapsedStationTime: { [key: string] : string; } = {};
    activeStatTime: { [key: string] : string; } = {};
    name: string;
    completedQty: number;

    constructor(data?: IWorkorderPartSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["elapsed-station-time"]) {
                this.elapsedStationTime = {};
                for (let key in data["elapsed-station-time"]) {
                    if (data["elapsed-station-time"].hasOwnProperty(key))
                        this.elapsedStationTime[key] = data["elapsed-station-time"][key];
                }
            }
            if (data["active-stat-time"]) {
                this.activeStatTime = {};
                for (let key in data["active-stat-time"]) {
                    if (data["active-stat-time"].hasOwnProperty(key))
                        this.activeStatTime[key] = data["active-stat-time"][key];
                }
            }
            this.name = data["name"];
            this.completedQty = data["completed-qty"];
        }
    }

    static fromJS(data: any): WorkorderPartSummary {
        data = typeof data === 'object' ? data : {};
        let result = new WorkorderPartSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.elapsedStationTime) {
            data["elapsed-station-time"] = {};
            for (let key in this.elapsedStationTime) {
                if (this.elapsedStationTime.hasOwnProperty(key))
                    data["elapsed-station-time"][key] = this.elapsedStationTime[key];
            }
        }
        if (this.activeStatTime) {
            data["active-stat-time"] = {};
            for (let key in this.activeStatTime) {
                if (this.activeStatTime.hasOwnProperty(key))
                    data["active-stat-time"][key] = this.activeStatTime[key];
            }
        }
        data["name"] = this.name;
        data["completed-qty"] = this.completedQty;
        return data;
    }
}

export interface IWorkorderPartSummary {
    elapsedStationTime: { [key: string] : string; };
    activeStatTime: { [key: string] : string; };
    name: string;
    completedQty: number;
}

export class SerialSettings implements ISerialSettings {
    serialType: SerialType;
    serialLength: number;
    depositOnProcess: number;
    filenameTemplate?: string;
    programTemplate?: string;

    constructor(data?: ISerialSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serialType = data["serialType"];
            this.serialLength = data["serialLength"];
            this.depositOnProcess = data["depositOnProcess"];
            this.filenameTemplate = data["filenameTemplate"];
            this.programTemplate = data["programTemplate"];
        }
    }

    static fromJS(data: any): SerialSettings {
        data = typeof data === 'object' ? data : {};
        let result = new SerialSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serialType"] = this.serialType;
        data["serialLength"] = this.serialLength;
        data["depositOnProcess"] = this.depositOnProcess;
        data["filenameTemplate"] = this.filenameTemplate;
        data["programTemplate"] = this.programTemplate;
        return data;
    }
}

export interface ISerialSettings {
    serialType: SerialType;
    serialLength: number;
    depositOnProcess: number;
    filenameTemplate?: string;
    programTemplate?: string;
}

export enum SerialType {
    NoSerials = <any>"NoSerials",
    OneSerialPerMaterial = <any>"OneSerialPerMaterial",
    OneSerialPerCycle = <any>"OneSerialPerCycle",
    SerialDeposit = <any>"SerialDeposit",
}

export class PluginInfo extends ValueType implements IPluginInfo {
    name?: string;
    version?: string;

    constructor(data?: IPluginInfo) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.name = data["name"];
            this.version = data["version"];
        }
    }

    static fromJS(data: any): PluginInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PluginInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["version"] = this.version;
        super.toJSON(data);
        return data;
    }
}

export interface IPluginInfo extends IValueType {
    name?: string;
    version?: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}